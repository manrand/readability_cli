

// Globals
var hrt_start, hrt_end;
var debug = false;
var saveFolder;
var targetURL;
var stripHTML = false;

var destRoot;

const FFX_UA = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.10; rv:38.0) Gecko/20100101 Firefox/38.0";


// Package dependencies
const path        = require("path");
const fs          = require("fs");
const { JSDOM }   = require("jsdom");
const fetch       = require('node-fetch');
const minimist    = require('minimist');
const Readability = require("readability");
const prettyPrint = require("./utils").prettyPrint;
const textVersion = require("textversionjs");

// Argument Parsing
var argv = minimist(process.argv.slice(2));

// Save results to folder with: '--save-folder {folder}'
if (argv['save-folder']) {
    saveFolder = argv['save-folder'];
    destRoot = path.join(saveFolder);
}

// URL is first param without '--' prefix
if (argv['_'][0])
    targetURL = argv['_'][0];

// Enable Debug with: '--debug 1'
if (argv['debug'] == 1)
    debug = true;

// Strip HTML
if (argv['strip-HTML'])
    stripHTML = true;


// Main
if (destRoot === undefined) {
    fetchSource(targetURL, parseHTMLData);
}
else {
    fs.mkdir(destRoot, function(err) {
        fetchSource(targetURL, parseHTMLData);
    });
}

var FETCH_OPTIONS = {
    headers: {
        "user-agent": FFX_UA,
    }
};

function fetchSource(URL, callbackFn) {
  if (debug) {
      console.log("Fetching " + URL);
  }
  if (!URL) {
    console.error("You should pass a URL if the source doesn't exist yet!");
    process.exit(1);
    return;
  }
  hrt_start = process.hrtime();
  fetch(URL, FETCH_OPTIONS)
        .then(function(result) {
            var HTMLData = result.text();

            hrt_end = process.hrtime(hrt_start);
            if (debug)
                console.log(">> Execution time (hr): %ds %dms", hrt_end[0], hrt_end[1]/1000000);

            return HTMLData;
        })
        .then(function(HTMLData) {
            return callbackFn(URL, HTMLData);
        });
}

const JSDOM_OPTIONS = {
    features: {
        FetchExternalResources: false,
        ProcessExternalResources: false
    }
};

const TEXTVERSION_OPTIONS = {
    linkProcess: function(href, linkText) {
        return linkText;
    },
    imgProcess: function(src, alt) {
        return alt;
    }
};

function parseHTMLData(sourceURL, HTMLData) {
  var sourcePath;
  var destPath;
  var metadataDestPath;
  hrt_start = process.hrtime();
  const _DOM = new JSDOM(HTMLData, JSDOM_OPTIONS);
  const _DOC = _DOM.window.document;

  Node = _DOM.window.Node;

  if (destRoot !== undefined) {
      sourcePath       = path.join(destRoot, "source.html");
      destPath         = path.join(destRoot, "result.html")
      metadataDestPath = path.join(destRoot, "result-metadata.json");
  }

  HTMLData = prettyPrint(_DOM.serialize());

  if (sourcePath) {
      if (debug) {
          console.log("Writing " + sourcePath);
      }

      fs.writeFile(sourcePath, HTMLData, function(err) {
          if (err) {
              console.error("Couldn't write data to " + sourcePath);
              console.error(err);
              return;
          }
      });
  }

  if (debug) {
    console.log("Parsing " + sourceURL);
  }

  var result;
  var readerable;
  try {
      const reader = new Readability(sourceURL, _DOC);

      readerable = reader.isProbablyReaderable();
      /*
         NOTE: the order is important here.
         Indeed, calling parse() first will make isProbablyReaderable() to always return false
      */
      result     = reader.parse();
  } catch (exception) {
      console.error(exception);
      exception.stack.forEach(console.log.bind(console));
  }

  if (!result) {
      console.error("No content generated by readability, not going to write expected.html!");
      return;
  }

  if (debug) {
      hrt_end = process.hrtime(hrt_start);
      console.log(">> Execution time (hr): %ds %dms", hrt_end[0], hrt_end[1]/1000000);

      console.log("> URI    :" + result.uri);
      console.log("> Title  : " + result.title);
      console.log("> Excerpt: " + result.excerpt);
      console.log("> By     :" + result.byline);
  }

  if (stripHTML)
      result.content = textVersion(prettyPrint(result.content), TEXTVERSION_OPTIONS);
  else
      result.content = prettyPrint(result.content);

  if (destPath) {
      fs.writeFile(destPath, result.content, function(fileWriteErr) {
          if (fileWriteErr) {
              console.error("Couldn't write result data to " + destPath);
              console.error(fileWriteErr);
          }
      });
  }
  else
      console.log(result.content);

  // Delete the result data we don't care about.
  delete result.content;
  delete result.textContent;
  delete result.length;

  // Add isProbablyReaderable result
  result.readerable = readerable;

  if (metadataDestPath) {
      fs.writeFile(metadataDestPath, JSON.stringify(result, null, 2) + "\n", function(metadataWriteErr) {
          if (metadataWriteErr) {
              console.error("Couldn't write data to expected-metadata.json!");
              console.error(metadataWriteErr);
          }
      });
  }

  return;
}
