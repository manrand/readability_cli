var debug = true;

var path = require("path");
var fs = require("fs");
const { JSDOM } = require("jsdom");
const fetch = require('node-fetch');
var Readability = require("readability");
var prettyPrint = require("./utils").prettyPrint;

var FFX_UA = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.10; rv:38.0) Gecko/20100101 Firefox/38.0";

if (process.argv.length < 3) {
  console.error("Need at least a destination slug and potentially a URL (if the slug doesn't have source).");
  process.exit(0);
  throw "Abort";
}

var slug = process.argv[2];
var argURL = process.argv[3]; // Could be undefined, we'll warn if it is if that is an issue.

var destRoot = path.join(slug);

fs.mkdir(destRoot, function(err) {
  fetchSource(argURL, parseHTMLData);
});

function fetchSource(URL, callbackFn) {
  if (debug) {
      console.log("Fetching " + URL);
  }
  if (!URL) {
    console.error("You should pass a URL if the source doesn't exist yet!");
    process.exit(1);
    return;
  }
  fetch(URL)
        .then(function(result) {
            var HTMLData = result.text();

            return HTMLData;
        })
        .then(function(HTMLData) {
            return callbackFn(URL, HTMLData);
        });
}

const JSDOM_OPTIONS = {
    features: {
        FetchExternalResources: false,
        ProcessExternalResources: false
    }
};

function parseHTMLData(sourceURL, HTMLData) {
  var sourcePath = path.join(destRoot, "source.html");
  var destPath = path.join(destRoot, "result.html")
  var metadataDestPath = path.join(destRoot, "result-metadata.json");
  const _DOM = new JSDOM(HTMLData, JSDOM_OPTIONS);
  const _DOC = _DOM.window.document;

  Node = _DOM.window.Node;

  if (debug) {
      console.log("Writing " + sourcePath);
  }

  HTMLData = prettyPrint(_DOM.serialize());

  fs.writeFile(sourcePath, HTMLData, function(err) {
      if (err) {
          console.error("Couldn't write data to " + sourcePath);
          console.error(err);
          return;
      }
  });

  if (debug) {
    console.log("Parsing " + sourceURL);
  }

  var result;
  var readerable;
  try {
      const reader = new Readability(sourceURL, _DOC);

      readerable = reader.isProbablyReaderable();
      /*
         NOTE: the order is important here.
         Indeed, calling parse() first will make isProbablyReaderable() to always return false
      */
      result     = reader.parse();
  } catch (exception) {
      console.error(exception);
      exception.stack.forEach(console.log.bind(console));
  }

  if (!result) {
      console.error("No content generated by readability, not going to write expected.html!");
      return;
  }

  if (debug) {
      console.log("> URI    :" + result.uri);
      console.log("> Title  : " + result.title);
      console.log("> Excerpt: " + result.excerpt);
      console.log("> By     :" + result.byline);
  }

  fs.writeFile(destPath, prettyPrint(result.content), function(fileWriteErr) {
      if (fileWriteErr) {
          console.error("Couldn't write result data to " + destPath);
          console.error(fileWriteErr);
      }
  });

  // Delete the result data we don't care about.
  delete result.content;
  delete result.textContent;
  delete result.length;

  // Add isProbablyReaderable result
  result.readerable = readerable;

  fs.writeFile(metadataDestPath, JSON.stringify(result, null, 2) + "\n", function(metadataWriteErr) {
      if (metadataWriteErr) {
          console.error("Couldn't write data to expected-metadata.json!");
          console.error(metadataWriteErr);
      }
  });

  return;
}
